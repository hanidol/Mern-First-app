{"ast":null,"code":"'use strict';\n\nvar _toConsumableArray = require(\"/Users/haninasri/Desktop/FulStuck/First-App/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/toConsumableArray\");\nvar _classCallCheck = require(\"/Users/haninasri/Desktop/FulStuck/First-App/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/classCallCheck\");\nvar _createClass = require(\"/Users/haninasri/Desktop/FulStuck/First-App/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/createClass\");\nvar _possibleConstructorReturn = require(\"/Users/haninasri/Desktop/FulStuck/First-App/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/possibleConstructorReturn\");\nvar _get = require(\"/Users/haninasri/Desktop/FulStuck/First-App/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/get\");\nvar _getPrototypeOf = require(\"/Users/haninasri/Desktop/FulStuck/First-App/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/getPrototypeOf\");\nvar _inherits = require(\"/Users/haninasri/Desktop/FulStuck/First-App/client/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/inherits\");\nvar Hoek = require('@hapi/hoek');\nvar Any = require('../any');\nvar Cast = require('../../cast');\nvar Ref = require('../../ref');\nvar internals = {};\ninternals.Alternatives = /*#__PURE__*/function (_Any) {\n  _inherits(_class, _Any);\n  function _class() {\n    var _this;\n    _classCallCheck(this, _class);\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(_class).call(this));\n    _this._type = 'alternatives';\n    _this._invalids.remove(null);\n    _this._inner.matches = [];\n    return _this;\n  }\n  _createClass(_class, [{\n    key: \"_init\",\n    value: function _init() {\n      return arguments.length ? this.try.apply(this, arguments) : this;\n    }\n  }, {\n    key: \"_base\",\n    value: function _base(value, state, options) {\n      var errors = [];\n      var il = this._inner.matches.length;\n      var baseType = this._baseType;\n      for (var i = 0; i < il; ++i) {\n        var item = this._inner.matches[i];\n        if (!item.schema) {\n          var schema = item.peek || item.is;\n          var input = item.is ? item.ref(state.reference || state.parent, options) : value;\n          var failed = schema._validate(input, null, options, state.parent).errors;\n          if (failed) {\n            if (item.otherwise) {\n              return item.otherwise._validate(value, state, options);\n            }\n          } else if (item.then) {\n            return item.then._validate(value, state, options);\n          }\n          if (i === il - 1 && baseType) {\n            return baseType._validate(value, state, options);\n          }\n          continue;\n        }\n        var result = item.schema._validate(value, state, options);\n        if (!result.errors) {\n          // Found a valid match\n          return result;\n        }\n        errors.push.apply(errors, _toConsumableArray(result.errors));\n      }\n      if (errors.length) {\n        return {\n          errors: this.createError('alternatives.child', {\n            reason: errors\n          }, state, options)\n        };\n      }\n      return {\n        errors: this.createError('alternatives.base', null, state, options)\n      };\n    }\n  }, {\n    key: \"try\",\n    value: function _try() {\n      for (var _len = arguments.length, schemas = new Array(_len), _key = 0; _key < _len; _key++) {\n        schemas[_key] = arguments[_key];\n      }\n      schemas = Hoek.flatten(schemas);\n      Hoek.assert(schemas.length, 'Cannot add other alternatives without at least one schema');\n      var obj = this.clone();\n      for (var i = 0; i < schemas.length; ++i) {\n        var cast = Cast.schema(this._currentJoi, schemas[i]);\n        if (cast._refs.length) {\n          var _obj$_refs;\n          (_obj$_refs = obj._refs).push.apply(_obj$_refs, _toConsumableArray(cast._refs));\n        }\n        obj._inner.matches.push({\n          schema: cast\n        });\n      }\n      return obj;\n    }\n  }, {\n    key: \"when\",\n    value: function when(condition, options) {\n      var schemaCondition = false;\n      Hoek.assert(Ref.isRef(condition) || typeof condition === 'string' || (schemaCondition = condition instanceof Any), 'Invalid condition:', condition);\n      Hoek.assert(options, 'Missing options');\n      Hoek.assert(typeof options === 'object', 'Invalid options');\n      if (schemaCondition) {\n        Hoek.assert(!options.hasOwnProperty('is'), '\"is\" can not be used with a schema condition');\n      } else {\n        Hoek.assert(options.hasOwnProperty('is'), 'Missing \"is\" directive');\n      }\n      Hoek.assert(options.then !== undefined || options.otherwise !== undefined, 'options must have at least one of \"then\" or \"otherwise\"');\n      var obj = this.clone();\n      var is;\n      if (!schemaCondition) {\n        is = Cast.schema(this._currentJoi, options.is);\n        if (options.is === null || !(Ref.isRef(options.is) || options.is instanceof Any)) {\n          // Only apply required if this wasn't already a schema or a ref, we'll suppose people know what they're doing\n          is = is.required();\n        }\n      }\n      var item = {\n        ref: schemaCondition ? null : Cast.ref(condition),\n        peek: schemaCondition ? condition : null,\n        is: is,\n        then: options.then !== undefined ? Cast.schema(this._currentJoi, options.then) : undefined,\n        otherwise: options.otherwise !== undefined ? Cast.schema(this._currentJoi, options.otherwise) : undefined\n      };\n      if (obj._baseType) {\n        item.then = item.then && obj._baseType.concat(item.then);\n        item.otherwise = item.otherwise && obj._baseType.concat(item.otherwise);\n      }\n      if (!schemaCondition) {\n        var _obj$_refs2;\n        Ref.push(obj._refs, item.ref);\n        (_obj$_refs2 = obj._refs).push.apply(_obj$_refs2, _toConsumableArray(item.is._refs));\n      }\n      if (item.then && item.then._refs.length) {\n        var _obj$_refs3;\n        (_obj$_refs3 = obj._refs).push.apply(_obj$_refs3, _toConsumableArray(item.then._refs));\n      }\n      if (item.otherwise && item.otherwise._refs.length) {\n        var _obj$_refs4;\n        (_obj$_refs4 = obj._refs).push.apply(_obj$_refs4, _toConsumableArray(item.otherwise._refs));\n      }\n      obj._inner.matches.push(item);\n      return obj;\n    }\n  }, {\n    key: \"label\",\n    value: function label(name) {\n      var obj = _get(_getPrototypeOf(_class.prototype), \"label\", this).call(this, name);\n      obj._inner.matches = obj._inner.matches.map(function (match) {\n        if (match.schema) {\n          return {\n            schema: match.schema.label(name)\n          };\n        }\n        match = Object.assign({}, match);\n        if (match.then) {\n          match.then = match.then.label(name);\n        }\n        if (match.otherwise) {\n          match.otherwise = match.otherwise.label(name);\n        }\n        return match;\n      });\n      return obj;\n    }\n  }, {\n    key: \"describe\",\n    value: function describe() {\n      var description = _get(_getPrototypeOf(_class.prototype), \"describe\", this).call(this);\n      var alternatives = [];\n      for (var i = 0; i < this._inner.matches.length; ++i) {\n        var item = this._inner.matches[i];\n        if (item.schema) {\n          // try()\n\n          alternatives.push(item.schema.describe());\n        } else {\n          // when()\n\n          var when = item.is ? {\n            ref: item.ref.toString(),\n            is: item.is.describe()\n          } : {\n            peek: item.peek.describe()\n          };\n          if (item.then) {\n            when.then = item.then.describe();\n          }\n          if (item.otherwise) {\n            when.otherwise = item.otherwise.describe();\n          }\n          alternatives.push(when);\n        }\n      }\n      description.alternatives = alternatives;\n      return description;\n    }\n  }]);\n  return _class;\n}(Any);\nmodule.exports = new internals.Alternatives();","map":null,"metadata":{},"sourceType":"script"}